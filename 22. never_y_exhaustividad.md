## IntroducciÃ³n

El tipo `never` en TypeScript representa **un valor que nunca ocurre**. Se usa en funciones que **no retornan nunca** o en validaciones de exhaustividad.

ðŸ“Œ **Casos de uso del tipo `never`**:  
âœ” Funciones que lanzan errores o entran en bucles infinitos.  
âœ” Garantizar que se manejan todos los casos en un `switch`.  
âœ” Ayudar a detectar errores en el cÃ³digo en tiempo de compilaciÃ³n.


## Funciones que Retornan `never`

Cuando una funciÃ³n **nunca retorna** (porque lanza un error o entra en un bucle infinito), su tipo de retorno es `never`.

```typescript
function lanzarError(mensaje: string): never {
  throw new Error(mensaje);
}

function bucleInfinito(): never {
  while (true) {
    console.log("Esto nunca termina");
  }
}
```

**Diferencia con `void`**:
- `void` se usa cuando una funciÃ³n no retorna un valor, pero sÃ­ finaliza.
- `never` se usa cuando una funciÃ³n **no puede terminar su ejecuciÃ³n**.


## `never` en Validaciones Exhaustivas

El tipo `never` es Ãºtil para asegurarnos de que hemos manejado **todas las posibilidades** en un `switch`.

```typescript
type Estado = "pendiente" | "completado" | "cancelado";

function manejarEstado(estado: Estado) {
  switch (estado) {
    case "pendiente":
      console.log("El estado es pendiente.");
      break;
    case "completado":
      console.log("El estado es completado.");
      break;
    case "cancelado":
      console.log("El estado es cancelado.");
      break;
    default:
      const _exhaustivo: never = estado; // âŒ Error si falta un caso
      throw new Error(`Estado no manejado: ${estado}`);
  }
}
```

Si en el futuro agregamos un nuevo estado (`"revisado"`), TypeScript generarÃ¡ un error, forzÃ¡ndonos a actualizar el `switch`.


## `never` en Tipos de Datos

El tipo `never` se usa cuando **una intersecciÃ³n de tipos es imposible**.

```typescript
type A = { tipo: "A"; valor: number };
type B = { tipo: "B"; nombre: string };
type C = A & B; // Nunca puede existir, por lo que C es de tipo `never`
```

La intersecciÃ³n `A & B` no es vÃ¡lida porque `tipo` no puede ser `"A"` y `"B"` al mismo tiempo.


## `never` en Funciones con `if` Incompletos

TypeScript puede inferir `never` en cÃ³digo con estructuras `if` incompletas.

```typescript
function verificarNumero(valor: number) {
  if (valor > 0) {
    return "Positivo";
  } else if (valor < 0) {
    return "Negativo";
  }
  // AquÃ­ `valor` deberÃ­a ser 0, pero no se maneja el caso
}
```

**Mejor soluciÃ³n:** Asegurar que todos los casos estÃ©n cubiertos.

```typescript
function verificarNumeroSeguro(valor: number): string {
  if (valor > 0) {
    return "Positivo";
  } else if (valor < 0) {
    return "Negativo";
  } else {
    return "Cero";
  }
}
```

Esto previene que TypeScript infiera `never` en caminos no manejados.


## Uso de `never` con `asertions`

Si estamos seguros de que una variable nunca tendrÃ¡ cierto valor, podemos usar `never` para hacer una aserciÃ³n.

```typescript
function procesarValor(valor: string | number) {
  if (typeof valor === "string") {
    console.log("Es un string:", valor);
  } else if (typeof valor === "number") {
    console.log("Es un nÃºmero:", valor);
  } else {
    const _exhaustivo: never = valor; // âŒ Error si aparece otro tipo
    throw new Error("Tipo inesperado");
  }
}
```

Nos ayuda a detectar errores si en el futuro `valor` puede ser de otro tipo inesperado.

