# Decoradores en TypeScript

## IntroducciÃ³n

Los **decoradores** son una caracterÃ­stica avanzada de TypeScript que permiten modificar clases, mÃ©todos, propiedades y parÃ¡metros en tiempo de ejecuciÃ³n.  
Son funciones que se aplican mediante `@decorador`, similares a los decoradores en Python o anotaciones en Java.


### Requisitos

- Los decoradores requieren que la opciÃ³n `experimentalDecorators` estÃ© habilitada en `tsconfig.json`.

```json
{
  "compilerOptions": {
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true
  }
}
```


## Tipos de Decoradores

TypeScript permite varios tipos de decoradores:

1. **Decoradores de Clases**
2. **Decoradores de MÃ©todos**
3. **Decoradores de Propiedades**
4. **Decoradores de ParÃ¡metros**
5. **Decoradores de Accesores (getters/setters)**


## Decoradores de Clases

Se aplican a una clase y pueden modificar su definiciÃ³n.

```typescript
function ConRegistro(target: Function) {
  console.log(`Clase registrada: ${target.name}`);
}

@ConRegistro
class Usuario {
  constructor(public nombre: string) {}
}
```

Cuando se define la clase `Usuario`, el decorador `@ConRegistro` **se ejecuta automÃ¡ticamente**.

Salida:

```bash
Clase registrada: Usuario
```

**Ejemplo Ãºtil:** Decorador para agregar una propiedad a la clase:

```typescript
function AgregarMetodo(target: Function) {
  target.prototype.saludar = function () {
    console.log("Hola desde la clase decorada");
  };
}

@AgregarMetodo
class Persona {}

const p = new Persona();
// @ts-ignore
p.saludar(); // âœ… "Hola desde la clase decorada"
```


## Decoradores de MÃ©todos

Se aplican sobre los mÃ©todos de una clase y permiten modificar su comportamiento.

```typescript
function Log(target: any, key: string, descriptor: PropertyDescriptor) {
  const metodoOriginal = descriptor.value;

  descriptor.value = function (...args: any[]) {
    console.log(`Llamando a ${key} con argumentos:`, args);
    return metodoOriginal.apply(this, args);
  };
}

class Calculadora {
  @Log
  sumar(a: number, b: number) {
    return a + b;
  }
}

const calc = new Calculadora();
console.log(calc.sumar(2, 3)); // âœ… Log + Resultado
```

Salida:

```bash
Llamando a sumar con argumentos: [2, 3] 5
```


## Decoradores de Propiedades

Permiten modificar el comportamiento de una propiedad en una clase.

```typescript
function ReadOnly(target: any, propertyKey: string) {
  Object.defineProperty(target, propertyKey, {
    writable: false,
  });
}

class Vehiculo {
  @ReadOnly
  marca: string = "Toyota";
}

const auto = new Vehiculo();
auto.marca = "Honda"; // âŒ Error: No se puede modificar
```

AquÃ­ `@ReadOnly` hace que `marca` **sea de solo lectura**.


## Decoradores de ParÃ¡metros

Se aplican a los parÃ¡metros de un mÃ©todo.

```typescript
function ParametroLog(target: any, methodName: string, paramIndex: number) {
  console.log(`ParÃ¡metro ${paramIndex} en el mÃ©todo ${methodName} fue decorado.`);
}

class Mensaje {
  mostrar(@ParametroLog texto: string) {
    console.log(texto);
  }
}

const msg = new Mensaje();
msg.mostrar("Hola"); 
```

Salida:

```bash
ParÃ¡metro 0 en el mÃ©todo mostrar fue decorado. 
Hola
```


## Decoradores de Accesores (getters/setters)

Se aplican a **getters o setters** de una clase.

```typescript
function BloquearSet(target: any, key: string, descriptor: PropertyDescriptor) {
  descriptor.set = function () {
    throw new Error(`No puedes modificar ${key}`);
  };
}

class Persona {
  private _edad: number = 0;

  @BloquearSet
  set edad(valor: number) {
    this._edad = valor;
  }

  get edad() {
    return this._edad;
  }
}

const p = new Persona();
p.edad = 30; // âŒ Error: No puedes modificar edad
```

AquÃ­ el decorador `@BloquearSet` **bloquea la modificaciÃ³n de `edad`**.


## Decoradores con ParÃ¡metros

Podemos crear decoradores mÃ¡s flexibles con parÃ¡metros.

```typescript
function Prefijo(prefijo: string) {
  return function (target: any, key: string) {
    let valor = target[key];

    Object.defineProperty(target, key, {
      get: () => `${prefijo} ${valor}`,
      set: (nuevoValor) => (valor = nuevoValor),
    });
  };
}

class Producto {
  @Prefijo("ðŸ”¹")
  nombre: string = "Laptop";
}

const prod = new Producto();
console.log(prod.nombre); // âœ… "ðŸ”¹ Laptop"
```

El decorador `@Prefijo("ðŸ”¹")` **modifica la propiedad `nombre`** aÃ±adiÃ©ndole un prefijo.


## ComposiciÃ³n de Decoradores

Podemos aplicar **varios decoradores** a un solo elemento.

```typescript
function Decorador1(target: any, key: string) {
  console.log("Ejecutando Decorador1");
}

function Decorador2(target: any, key: string) {
  console.log("Ejecutando Decorador2");
}

class Ejemplo {
  @Decorador1
  @Decorador2
  metodo() {}
}
```

Salida:

```bash
Ejecutando Decorador2
Ejecutando Decorador1
```

**Los decoradores se ejecutan de abajo hacia arriba**.


## CuÃ¡ndo Usar Decoradores

âœ” Cuando necesitas **modificar clases/mÃ©todos sin cambiar el cÃ³digo original**.  
âœ” En **marcos de trabajo como Angular, NestJS** que usan decoradores para inyecciÃ³n de dependencias.  
âœ” Para **programaciÃ³n orientada a aspectos (AOP)**.  
âœ” Para crear **logs, validaciones o metaprogramaciÃ³n**.