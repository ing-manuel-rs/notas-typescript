# Mejores PrÃ¡cticas en TypeScript

## **IntroducciÃ³n**

TypeScript es una herramienta poderosa que mejora la calidad del cÃ³digo de JavaScript con tipado estÃ¡tico, interfaces y otras caracterÃ­sticas avanzadas. Sin embargo, su correcto uso es clave para mantener un cÃ³digo limpio, mantenible y eficiente.

**Objetivo**: Aprender mejores prÃ¡cticas para escribir cÃ³digo TypeScript claro, seguro y escalable.


## **1. ConfiguraciÃ³n Ã“ptima del Proyecto**

### **1.1 Personalizar `tsconfig.json`**

El archivo `tsconfig.json` define cÃ³mo TypeScript debe interpretar y transpirar el cÃ³digo.

Ejemplo recomendado:

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "resolveJsonModule": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true
  }
}
```

**Claves importantes**:  
âœ” `strict: true`: Activa el modo estricto para mejor seguridad.  
âœ” `noImplicitAny: true`: Evita el uso de `any` implÃ­cito.  
âœ” `noUnusedLocals` y `noUnusedParameters`: Ayuda a mantener el cÃ³digo limpio.


## **2. Uso Correcto de Tipos**

### **2.1 Evitar `any`, Preferir Tipos ExplÃ­citos**

```typescript
// âŒ Mal uso de any
let user: any = "Juan"; 
user = 123;

// âœ… Mejor: usar tipos especÃ­ficos
let user: string = "Juan";
let age: number = 30;
```

### **2.2 Usar `unknown` en Lugar de `any` si es Necesario**

```typescript
function process(value: unknown) {
  if (typeof value === "string") {
    console.log(value.toUpperCase());
  }
}
```

`unknown` es mÃ¡s seguro que `any`, ya que obliga a realizar verificaciones antes de usarlo.

### **2.3 Preferir `readonly` en Objetos Inmutables**

```typescript
interface Config {
  readonly API_URL: string;
}

const config: Config = { API_URL: "https://api.example.com" };
// config.API_URL = "otro valor"; âŒ Error
```


## **3. Mejoras en Funciones**

### **3.1 Tipar los ParÃ¡metros y Retornos**

```typescript
// âœ… Especificar el tipo de retorno
function add(a: number, b: number): number {
  return a + b;
}
```

### **3.2 Usar ParÃ¡metros Opcionales con `?`**

```typescript
function greet(name: string, age?: number) {
  return age ? `Hola ${name}, tienes ${age} aÃ±os.` : `Hola ${name}`;
}
```

### **3.3 Definir Funciones Flecha con Tipado Claro**

```typescript
const multiply = (a: number, b: number): number => a * b;
```


## **4. Uso Correcto de `type` e `interface`**

### **4.1 CuÃ¡ndo Usar `type` vs `interface`**

- **`type`**: Para alias de tipos primitivos, uniones e intersecciones.
- **`interface`**: Para definir la estructura de objetos y clases.

```typescript
type ID = string | number; // Alias de tipo
interface User { id: ID; name: string; }
```

### **4.2 Extender Interfaces**

```typescript
interface Person {
  name: string;
}

interface Employee extends Person {
  salary: number;
}
```

**Evita `extends` en `type`, ya que no funciona de la misma manera que en `interface`**.


## **5. Clases y ProgramaciÃ³n Orientada a Objetos**

### **5.1 Usar Modificadores de Acceso Correctamente**

```typescript
class Car {
  private brand: string;
  constructor(brand: string) {
    this.brand = brand;
  }
  public getBrand() {
    return this.brand;
  }
}
```

`private` oculta los detalles internos de la clase.

### **5.2 Implementar Interfaces en Clases**

```typescript
interface Drivable {
  drive(): void;
}

class Truck implements Drivable {
  drive() {
    console.log("El camiÃ³n estÃ¡ en movimiento");
  }
}
```

**Las interfaces ayudan a definir contratos que las clases deben cumplir.**


## **6. GenÃ©ricos para CÃ³digo Reutilizable**

```typescript
function identity<T>(value: T): T {
  return value;
}
```

Los **genÃ©ricos** hacen que las funciones y clases sean mÃ¡s flexibles sin perder el tipado.

```typescript
class Box<T> {
  constructor(private content: T) {}
  getContent(): T {
    return this.content;
  }
}
```


## **7. Manejando Errores con TypeScript**

### **7.1 Usar `try/catch` con Tipado Correcto**

```typescript
try {
  throw new Error("Algo saliÃ³ mal");
} catch (error) {
  if (error instanceof Error) {
    console.error(error.message);
  }
}
```

**Nunca uses `catch (error: any)`**, ya que pierde los beneficios del tipado.

### **7.2 Usar `never` para Funciones que Nunca Retornan**

```typescript
function throwError(message: string): never {
  throw new Error(message);
}
```

`never` indica que la funciÃ³n nunca retorna un valor vÃ¡lido.


## **8. Buenas PrÃ¡cticas de OrganizaciÃ³n del CÃ³digo**

### **8.1 Usar MÃ³dulos en Lugar de Archivos Gigantes**

```typescript
// user.ts
export interface User {
  id: number;
  name: string;
}

// main.ts
import { User } from "./user";
```

**Cada mÃ³dulo debe tener una sola responsabilidad**.

### **8.2 Estructura Recomendada de un Proyecto**

```bash
ðŸ“¦ src
 â”£ ðŸ“‚ models       // Definiciones de interfaces y tipos
 â”£ ðŸ“‚ services     // LÃ³gica de negocio
 â”£ ðŸ“‚ utils        // Funciones de utilidad
 â”£ ðŸ“‚ components   // Componentes reutilizables (para React o Vue)
 â”— ðŸ“‚ pages        // Vistas principales (para Next.js)
```


## **9. Uso de `eslint` y `prettier` con TypeScript**

```bash
npm install --save-dev eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin
```

Ejemplo de configuraciÃ³n `.eslintrc.json`:

```json
{
  "parser": "@typescript-eslint/parser",
  "extends": ["plugin:@typescript-eslint/recommended"],
  "rules": {
    "no-unused-vars": "warn",
    "prefer-const": "error"
  }
}
```

Esto ayuda a evitar errores y mejorar la calidad del cÃ³digo.